# گزارش آزمایش
<div dir="rtl" align="justify">
    

برای پیاده سازی وضعیت بسته از الگوی state استفاده کردیم. ابتدا یک interface با نام PackageStatus ایجاد شد که تنها یک تابع printStatus دارد. سپس دو کلاس Delivered و InTransit ساخته شد که این interface را پیاده سازی می‌کنند و وضعیت‌های مختلف بسته را نشان می‌دهند. در ادامه فیلد packageStatus را به کلاس Package اضافه می‌کنیم که وضعیت بسته را نشان می‌دهد و از نوع PackageStatus است. به این صورت الگوی state محقق می‌شود و اجازه می‌دهیم یک object از کلاس Package وضعیت خود را تغییر دهد و در پی آن رفتارش نیز تغییر کند.

<img src="./images/1.png" />
<img src="./images/2.png" />
<img src="./images/3.png" />

برای پیاده سازی روش جابجایی بسته و الگوریتم‌های مختلف قیمت گذاری از الگوی Strategy استفاده می‌کنیم. ابتدا یک interface با نام NavigationStrategy ایجاد شد که شامل تابع calculateNavigationPrice است. سپس دو کلاس با نام‌های ExpressNavigation و StandardNavigation ساخته شد که این interface را پیاده سازی می‌کنند و هر کدام الگوریتم قیمت دهی مربوط به خود را در تابع calculateNavigationPrice دارند. در ادامه فیلد navigationStrategy را به کلاس Package اضافه میکنیم که روش جابجایی بسته را نشان می‌دهد و از نوع NavigationStrategy است. به این صورت الگوی Strategy محقق می‌شود و هر الگوریتم یا استراتژی قیمت دهی(شامل express و standard) را در یک کلاس جداگانه قرار داده‌ایم و هر package رفرنسی به یکی از این استراتژی‌ها دارد که وظیفه قیمت دهی را به آن delegate می‌کند.

<img src="./images/4.png" />
<img src="./images/5.png" />
<img src="./images/6.png" />

همانطور که اشاره شد باید فیلدهای مربوط به وضعیت بسته و نحوه جابجایی آن را به کلاس Package اضافه کنیم.

<img src="./images/7.png" />

مطابق خواسته دستورکار ابتدا وزن بسته به عنوان ورودی گرفته می‌شود و با آن یک object از کلاس Package ساخته می‌شود. سپس در یک حلقه روش ارسال و سپس وضعیت بسته دریافت می‌شود. اینکار را تا جایی ادامه می‌دهیم که بسته به مقصد نرسیده باشد. در این حلقه امکان تغییر وضعیت بسته و نحوه جابجایی وجود دارد و پس از هر بار تغییر پیام مربوطه چاپ می‌شود.

<img src="./images/8.png" />
<img src="./images/9.png" />
<img src="./images/10.png" />
<img src="./images/11.png" />

نمونه‌ خروجی برنامه:

<img src="./images/12.png" />

تمام مراحل پیاده سازی از روش TDD استفاده شده است. به این صورت که ابتدا تست مربوط به عملکرد نوشته شده است و سپس functionality مربوطه پیاده سازی شده است تا تست‌ها را پاس کند. در ادامه نیز تلاش شد تا خوانایی کد تا حد امکان بهتر شود.

</div>

### سوالات
## در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.
در کتاب GoF سه دسته الگوی طراحی معرفی شده اند که در ادامه هر یک از آن ها را توضیح مختصری میدهیم:
الگوهای سازنده (Creational Patterns):
این الگوها به فرایند ایجاد شیء متمرکز هستند و کمک می‌کنند تا روش‌های مختلفی برای ایجاد شیء را مدیریت کنیم. برخی از الگوهای سازنده شناخته شده شامل Factory Method، Abstract Factory، Singleton و Builder می‌باشند.

الگوهای رفتاری (Behavioral Patterns):
این الگوها به تعامل بین شیء‌ها و تقسیم کارها بین آن‌ها متمرکز هستند. آن‌ها رفتارهای مشترکی را برای اشیاء تعریف می‌کنند و به فعالیت‌ها و نحوه ارتباط بین آن‌ها کمک می‌کنند. برخی از الگوهای رفتاری معروف شامل Observer، Strategy، State و Command هستند.

الگوهای ساختاری (Structural Patterns):
این الگوها به ترکیب شیء‌ها به یکدیگر، برخورداری از یک واسط یا چیدمان بهتر برای این شیء‌ها متمرکز هستند. آن‌ها در برقراری ارتباط و تعامل بین اشیاء و جلوگیری از اتلاف حافظه و زمان کمک کرده و بهبود عملکرد سیستم را فراهم می‌کنند. برخی از الگوهای ساختاری شناخته شده عبارتند از Adapter، Decorator، Proxy و Composite.
## الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟
الگوهای state و strategy در این آزمایش مورد استفاده قرار گرفته اند.
این دو از آنجایی که بر الگوریتم ها و تخصیص مسولیت بین اشیا متمرکز هستند پس از نوع رفتاری هستند.
هر کدام از دو الگوی بالا را در ادامه مختصرا توضیح میدهیم:
الگوی State:
الگوی State به شیء امکان تغییر کردن رفتار خود در زمان اجرا می‌دهد، به وضوح یک شیء وضعیت خود را تغییر می‌دهد. این الگو کمک می‌کند تا رفتارهای مرتبط با هر وضعیت به صورت جداگانه پیاده‌سازی شود و شیء خود از تغییرات وضعیت خود خبرگیر باشد. این الگو برای مواردی مناسب است که شیء مورد نظر وضعیت‌های مختلفی دارد و باید به انعطافپذیری بالایی برای تغییر رفتار در وضعیت‌های مختلف دست پیدا کند.

الگوی Strategy:
الگوی Strategy به شیء امکان تغییر الگوی عملکرد خود را فراهم می‌کند. در این الگو، یک خانواده از الگوریتم‌ها تعریف می‌شود و هر یک از این الگوریتم‌ها به صورت مستقل از سایرین قابل استفاده و تعویض هستند. این الگو به کاربر امکان انتخاب و تعیین الگوریتم مورد نیاز برای اشیاء فراهم می‌کند و به این شیوه امکان پیاده‌سازی الگوریتم‌های مختلف برای یک عملکرد خاص را فراهم می‌سازد.


##  با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.
با توجه به اینکه در هر اجرا تنها یک بسته وجود دارد و هیچ بسته‌ی دیگری وجود نخواهد داشت، الگوی طراحی Singleton برای ایجاد و مدیریت این بسته مناسب است. 
از دلایل انتخاب الگوی Singleton میتوان به موارد زیر اشاره کرد:
کنترل ایجاد شیء: الگوی Singleton تضمین می‌کند که تنها یک نمونه از کلاس Package ایجاد می‌شود. و ما با توجه به مسئله ای که با آن مواجه هستیم فقط به یک بسته در هر اجرایمان نیاز داریم که این مورد نیاز ما را بر آورده میکند.
دسترسی سراسری: الگوی Singleton دسترسی سراسری به instance کلاس فراهم می‌کند. 
مدیریت ساده: با استفاده از Singleton، مدیریت بسته بسیار ساده و بدون پیچیدگی خواهد بود.

نحوه تحقق الگوی Singleton:
برای پیاده‌سازی الگوی Singleton در کلاس Package مراحل زیر را انجام می‌دهیم:
1- ایجاد یک متغیر استاتیک خصوصی که تنها نمونه‌ای از کلاس را نگه‌داری می‌کند.
2- جلوگیری از ایجاد نمونه‌های متعدد با خصوصی کردن سازنده کلاس Package 
3- ایجاد یک متد عمومی استاتیک که وظیفه برگرداندن نمونه‌ی Singleton را برعهده دارد و در صورت نیاز آن را ایجاد می‌کند.


## تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).
- SRP (Single Responsibility Principle): الگوی Singleton ممکن است نقض اصل SRP را داشته باشد زیرا مسئولیت‌های ایجاد و مدیریت یک نمونه یکتای از یک کلاس را بر عهده دارد و اگر وظایف مختلف و متعدد به طور بیش از حد به آن بدهیم ممکن است این اصل نقض شود.
- OCP (Open/Closed Principle): الگوی Singleton معمولاً قابلیت توسعه و تغییر را محدود می‌کند، بنابراین میتوان نقض اصل OCP را داشته باشد زیرا تغییر در عملکرد singleton نیاز به تغییر در کلاس نیز دارد که این اصل را نقض میکند.
- LSP (Liskov Substitution Principle): الگوی Singleton نقض اصل LSP را ندارد زیرا ارث‌بری از یک کلاس Singleton به عنوان یک کلاس منفرد به همان شکل انجام می‌شود. البته چنانچه که سینگلتون به صورت مستقیم از کلاس یا interface پایه استفاده نکند این امکان وجود دارد که این اصل نقش شود.
- ISP (Interface Segregation Principle): الگوی Singleton نقض اصل ISP را ندارد مگر آنکه استفاده از این الگو موجب ایجاد یک کلاس بزرگ و پیچیده شود که از بخش‌های مختلف واسطه الگو برای انجام وظایف مختلف استفاده می‌کند.
- DIP (Dependency Inversion Principle): الگوی Singleton چنانچه از تزریق وابستگی ها و اینترفیس ها برای وابستگی های خود استفاده کند میتواند این اصل محقق شود. اما معمولاً یک وابستگی شدید به نمونه خود دارد که می‌تواند نقض اصل DIP را نشان دهد، زیرا کلاس‌های دیگر وابسته به نمونه Singleton هستند و این وابستگی می‌تواند مشکلاتی در تست و تعویض ایجاد کند.

